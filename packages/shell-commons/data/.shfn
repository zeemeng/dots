#!/usr/bin/env sh

# Custom function to "cd" and "ls" a given directory
c () {
	cd "$@" && printf "> $(pwd)\n\n" && ls -lAhF
}

# `cd` into the parent git root directory
cgr () {
	cd "$(git rev-parse --show-toplevel)"
}

# `docker exec -it` convenience function. Defaults to targeting the first container listed by `docker ps` and defaults to invoking the command `bash`.
dexit () {
	case "$#" in
		0) docker exec -it "$(docker ps -aq | head -n1)" bash;;
		1) docker exec -it "$(docker ps -aq | head -n1)" "$@";;
		*) docker exec -it "$@";;
	esac
}

# Same as the `dexit` function defined above, but restart the target container first.
dreexit () (
	set -e

	case "$#" in
		0) dreexit_container="$(docker ps -aq | head -n1)"; set 'bash';;
		1) dreexit_container="$(docker ps -aq | head -n1)";;
		*) dreexit_container="$1"; shift;;
	esac

	docker restart "$dreexit_container"
	docker exec -it "$dreexit_container" "$@"
)

# Quicker docker help commands
dh () {
	docker "$@" --help
}

# Chain `jq` and `less` with colorized output
jql () {
	jq --color-output "$@" | less -R
}

l () {
	eval "$@" | less +Gg
}

# List each segment of the PATH env var, one per line.
lp () {
	echo "$PATH" | tr ':' '\n'
}

# List each segment of the expanded argument as a colon-separated list, one per line.
lvar () {
	echo "$@" | tr ':' '\n'
}

# Takes a single argument representing a pathname. Creates the specified pathname and `cd` into it.
mkcd () {
	mkdir -p "$1" && cd "$1"
}

# Wrapper function for suppressing stderr
noerr() {
	"$@" 2>/dev/null
}

# Wrapper function for suppressing stdout and stderr
noout() {
	"$@" >/dev/null 2>&1
}

# Invoke neovim using the configuration profile specified by "$1"
nva() (
	APPNAME="$1" && shift
	NVIM_APPNAME="$APPNAME" nvim "$@"
)

ps1_define_colors () {
	# Variables to help produce a properly formatted SGR sequence wrapped as a non-printing
	# Bash prompt sequence. A valid PS1 sequence shall be of a format like such:
	# 	${ESC_L}${SGR_L}...${SGR_R}${ESC_R}
	# where '...' represents a colon separated list of SGR parameters.
	#
	# See references:
	# https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html
	# https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
	#
	# Excerpt:
	# 38	Set foreground color	Next arguments are 5;n or 2;r;g;b
	# 38	Set foreground color	Next arguments are 5;n or 2;r;g;b
	#
	# For values of `n`, see:
	# https://en.wikipedia.org/wiki/ANSI_escape_code#Colors

	local ESC_L='\[' # Start of unprintable bash PS1 sequence
	local ESC_R='\]' # End of unprintable bash PS1 sequence
	local SGR_L='\033[' # ANSI Control Sequence Introducer (CSI) token
	local SGR_R='m'
	local BOLD_FG='1;38;' # SGR params.
	local RESET='0' # SGR param. Turn off all attributes

	PS1_CYAN=$(printf "${SGR_L}${BOLD_FG}5;36${SGR_R}")
	PS1_BLUE=$(printf "${SGR_L}${BOLD_FG}5;33${SGR_R}")
	PS1_RED=$(printf "${SGR_L}1;31${SGR_R}")
	PS1_GREEN=$(printf "${SGR_L}1;32${SGR_R}")
	PS1_YELLOW=$(printf "${SGR_L}38;5;227${SGR_R}")
	PS1_RESET=$(printf "${SGR_L}0${SGR_R}")

	PS1_GIT_GREEN=$(printf "${SGR_L}0;38;5;42${SGR_R}")
	PS1_GIT_RED=$(printf "${SGR_L}0;38;5;203${SGR_R}")
	PS1_GIT_BLUE=$(printf "${SGR_L}0;38;5;39${SGR_R}")
}

ps1_git_info () {
	if command -v git >/dev/null; then
		local BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null)
		local COMMIT=$(git rev-parse --short HEAD 2>/dev/null)
		local UNTRACKED=0
		local MODIFIED=0
		local STAGED=0
		local STAT_LABEL=''

		if [ "$COMMIT" ]; then
			while IFS=$'\n' read -r STAT_LINE; do
				case "$STAT_LINE" in
					'') ;;
					'??'*) UNTRACKED=$((UNTRACKED + 1));;
					' '*) MODIFIED=$((MODIFIED + 1));;
					?' '*) STAGED=$((STAGED + 1));;
					*) MODIFIED=$((MODIFIED + 1)); STAGED=$((STAGED + 1));;
				esac
			done <<-EOF
				$(git status --porcelain)
			EOF
		fi

		if [ $((UNTRACKED + MODIFIED + STAGED)) -ne 0 ]; then
			STAT_LABEL="${PS1_GIT_GREEN}${STAGED}S${PS1_RESET} ${PS1_GIT_RED}${MODIFIED}M${PS1_RESET} ${PS1_GIT_BLUE}${UNTRACKED}U${PS1_RESET}"
			STAT_LABEL="${STAT_LABEL##${PS1_GIT_GREEN}0S${PS1_RESET} }"
			STAT_LABEL="${STAT_LABEL##${PS1_GIT_RED}0M${PS1_RESET} }"
			STAT_LABEL="${STAT_LABEL%% ${PS1_GIT_BLUE}0U${PS1_RESET}}"
			STAT_LABEL="${STAT_LABEL%% ${PS1_GIT_RED}0M${PS1_RESET}}"
			STAT_LABEL=" ✗ $STAT_LABEL"
		fi

		if [ "$BRANCH" ]; then
			printf " (${PS1_YELLOW}${BRANCH}${PS1_RESET}${STAT_LABEL})"
		elif [ "$COMMIT" ]; then
			printf " ($PS1_YELLOW%.4s${PS1_RESET}$STAT_LABEL)" "$COMMIT"
		fi
	fi
}

ps1_exit_status () {
	if [ "$1" -eq 0 ]; then
		printf " ${PS1_GREEN}√${PS1_RESET}"
	else
		printf " ${PS1_RED}!$1${PS1_RESET}"
	fi
}

# Source drop-in files
if [ -d ~/.shfn.d ]; then
	for func_def in ~/.shfn.d/*; do
		case "$func_def" in
			*.test) ;;
			*) . "$func_def" ;;
		esac
	done
fi

# Source some local function definition file if it exists
if [ -f ~/.shfn.local ]; then
	. ~/.shfn.local
fi

